//
// Created by droc101 on 7/18/25.
//

#include <array>
#include <assimp/Importer.hpp>
#include <assimp/mesh.h>
#include <assimp/postprocess.h>
#include <assimp/scene.h>
#include <cstddef>
#include <cstdint>
#include <cstdio>
#include <format>
#include <fstream>
#include <libassets/util/DataReader.h>
#include <libassets/util/DataWriter.h>
#include <libassets/util/ModelLod.h>
#include <libassets/util/ModelVertex.h>
#include <numeric>
#include <stdexcept>
#include <string>
#include <unordered_map>
#include <vector>

ModelLod::ModelLod(DataReader &reader, const uint32_t materialsPerSkin)
{
    distance = reader.Read<float>();
    reader.Skip<float>();
    const size_t vertexCount = reader.Read<size_t>();
    for (size_t _i = 0; _i < vertexCount; _i++)
    {
        vertices.emplace_back(reader);
    }
    reader.Skip<uint32_t>(); // Skips the total index count which is not needed for editing
    for (uint32_t _i = 0; _i < materialsPerSkin; _i++)
    {
        indexCounts.push_back(reader.Read<uint32_t>());
    }
    for (const uint32_t indexCount: indexCounts)
    {
        std::vector<uint32_t> indices;
        for (size_t _i = 0; _i < indexCount; _i++)
        {
            indices.push_back(reader.Read<uint32_t>());
        }
        materialIndices.push_back(indices);
    }
}

ModelLod::ModelLod(const std::string &filePath, const float distance)
{
    this->distance = distance;

    std::unordered_map<ModelVertex, uint32_t> vertexToIndex;

    Assimp::Importer importer;
    const aiScene *scene = importer.ReadFile(filePath,
                                             aiProcess_Triangulate |
                                             aiProcess_JoinIdenticalVertices |
                                             aiProcess_SortByPType |
                                             aiProcess_ValidateDataStructure |
                                             aiProcess_FlipUVs |
                                             aiProcess_GenSmoothNormals);

    if (scene == nullptr || (scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE) != 0u || scene->mRootNode == nullptr)
    {
        printf("Assimp error: %s\n", importer.GetErrorString());
        throw std::runtime_error("assimp error, check stdout");
    }

    for (uint32_t i = 0; i < scene->mNumMeshes; i++)
    {
        const aiMesh *mesh = scene->mMeshes[i];
        const uint32_t materialIndex = mesh->mMaterialIndex;

        if (materialIndex >= materialIndices.size())
        {
            materialIndices.resize(materialIndex + 1);
        }

        std::vector<uint32_t> &indices = materialIndices[materialIndex];

        for (uint32_t j = 0; j < mesh->mNumFaces; j++)
        {
            const aiFace &face = mesh->mFaces[j];
            for (uint32_t k = 0; k < face.mNumIndices; k++)
            {
                const uint32_t vertexIndex = face.mIndices[k];
                const ModelVertex vertex(mesh, vertexIndex);
                if (vertexToIndex.contains(vertex))
                {
                    indices.push_back(vertexToIndex.at(vertex));
                } else
                {
                    indices.push_back(this->vertices.size());
                    this->vertices.push_back(vertex);
                    vertexToIndex[vertex] = indices.back();
                }
            }
        }
    }

    std::vector<int64_t> toErase{};
    for (uint32_t i = 0; i < materialIndices.size(); i++)
    {
        const std::vector<uint32_t> &indices = materialIndices[i];
        if (indices.size() < 3) // check for materials with no triangles
        {
            toErase.push_back(i);
        }
        indexCounts.push_back(indices.size());
    }

    for (const int64_t &index: toErase)
    {
        materialIndices.erase(materialIndices.begin() + index);
        indexCounts.erase(indexCounts.begin() + index);
    }
}

void ModelLod::Export(const char *path) const
{
    std::ofstream file(path);
    file << "# Generated by GAME SDK\n\n";
    for (const ModelVertex &vertex: vertices)
    {
        std::array<float, 4> color = vertex.color.CopyData();
        file << std::format("v {} {} {} {} {} {} {}\n",
                            vertex.position[0],
                            vertex.position[1],
                            vertex.position[2],
                            color[0],
                            color[1],
                            color[2],
                            color[3]);
        file << std::format("vt {} {}\n", vertex.uv[0], vertex.uv[1]);
        file << std::format("vn {} {} {}\n", vertex.normal[0], vertex.normal[1], vertex.normal[2]);
    }

    file << "\n\n";

    for (size_t m = 0; m < materialIndices.size(); m++)
    {
        file << std::format("usemtl mat_{}\n", m);
        for (uint32_t i = 0; i < indexCounts.at(m); i += 3)
        {
            const uint32_t index0 = materialIndices.at(m).at(i + 0) + 1;
            const uint32_t index1 = materialIndices.at(m).at(i + 1) + 1;
            const uint32_t index2 = materialIndices.at(m).at(i + 2) + 1;
            file << std::format("f {0}/{0}/{0} {1}/{1}/{1} {2}/{2}/{2}\n", index0, index1, index2);
        }
        file << "\n";
    }

    file.close();
}

void ModelLod::Write(DataWriter &writer) const
{
    writer.Write<float>(distance);
    writer.Write<float>(distance * distance);
    writer.Write<size_t>(vertices.size());
    for (const ModelVertex &vertex: vertices)
    {
        writer.WriteBuffer<float, 3>(vertex.position);
        writer.WriteBuffer<float, 2>(vertex.uv);
        vertex.color.WriteFloats(writer);
        writer.WriteBuffer<float, 3>(vertex.normal);
    }
    const uint32_t totalIndexCount = std::accumulate(indexCounts.begin(), indexCounts.end(), 0ul);
    writer.Write<uint32_t>(totalIndexCount);
    writer.WriteBuffer<uint32_t>(indexCounts);
    for (const std::vector<uint32_t> &lodIndices: materialIndices)
    {
        writer.WriteBuffer<uint32_t>(lodIndices);
    }
}
