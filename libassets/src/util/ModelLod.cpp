//
// Created by droc101 on 7/18/25.
//

#include <libassets/util/ModelLod.h>
#include <fstream>
#include <numeric>
#include <assimp/Importer.hpp>
#include <assimp/postprocess.h>
#include <assimp/scene.h>
#include <unordered_map>
#include "libassets/util/DataWriter.h"

ModelLod::ModelLod(DataReader &reader, const uint32_t materialCount)
{
    distance = reader.Read<float>();
    const size_t vertexCount = reader.Read<size_t>();
    for (size_t _i = 0; _i < vertexCount; _i++)
    {
        vertices.emplace_back(reader);
    }
    reader.Skip<uint32_t>(); // Skips the total index count which is not needed for editing
    for (uint32_t _i = 0; _i < materialCount; _i++)
    {
        indexCounts.push_back(reader.Read<size_t>());
    }
    for (const uint32_t indexCount: indexCounts)
    {
        std::vector<uint32_t> materialIndices;
        for (size_t _i = 0; _i < indexCount; _i++)
        {
            materialIndices.push_back(reader.Read<size_t>());
        }
        indices.push_back(materialIndices);
    }
}

ModelLod::ModelLod(const char *filePath, const float distance)
{
    this->distance = distance;

    std::unordered_map<ModelVertex, uint32_t> vertexToIndex;

    Assimp::Importer importer;
    const aiScene *scene = importer.ReadFile(filePath,
                                             aiProcess_Triangulate |
                                             aiProcess_JoinIdenticalVertices |
                                             aiProcess_SortByPType |
                                             aiProcess_ValidateDataStructure |
                                             aiProcess_FlipUVs |
                                             aiProcess_GenSmoothNormals);

    if (scene == nullptr || (scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE) != 0u || scene->mRootNode == nullptr)
    {
        printf("Assimp error: %s\n", importer.GetErrorString());
        throw std::runtime_error("assimp error, check stdout");
    }

    for (uint32_t i = 0; i < scene->mNumMeshes; i++)
    {
        const aiMesh *mesh = scene->mMeshes[i];
        const uint32_t materialIndex = mesh->mMaterialIndex;

        if (materialIndex >= this->indices.size())
        {
            this->indices.resize(materialIndex + 1);
        }

        std::vector<uint32_t> &indices = this->indices[materialIndex];

        for (uint32_t j = 0; j < mesh->mNumFaces; j++)
        {
            const aiFace &face = mesh->mFaces[j];
            for (uint32_t k = 0; k < face.mNumIndices; k++)
            {
                const uint32_t vertexIndex = face.mIndices[k];
                const ModelVertex v(mesh, vertexIndex);
                if (vertexToIndex.contains(v))
                {
                    indices.push_back(vertexToIndex.at(v));
                } else
                {
                    indices.push_back(this->vertices.size());
                    this->vertices.emplace_back(mesh, vertexIndex);
                    vertexToIndex[v] = indices.back();
                }
            }
        }
    }

    std::vector<int64_t> toErase{};
    for (uint32_t i = 0; i < this->indices.size(); i++)
    {
        const std::vector<uint32_t> &is = this->indices[i];
        if (is.size() < 3) // check for materials with no triangles
        {
            toErase.push_back(i);
        }
        this->indexCounts.push_back(is.size());
    }

    for (const int64_t &i: toErase)
    {
        this->indices.erase(this->indices.begin() + i);
        this->indexCounts.erase(this->indexCounts.begin() + i);
    }
}

void ModelLod::Export(const char *path) const
{
    std::ofstream f(path);
    f << "# Generated by GAME SDK\n\n";
    for (const ModelVertex &v: vertices)
    {
        std::array<float, 4> color = v.color.CopyData();
        f << std::format("v {} {} {} {} {} {} {}\n", v.position[0], v.position[1], v.position[2], color[0], color[1], color[2], color[3]);
        f << std::format("vt {} {}\n", v.uv[0], v.uv[1]);
        f << std::format("vn {} {} {}\n", v.normal[0], v.normal[1], v.normal[2]);
    }

    f << "\n\n";

    for (size_t m = 0; m < indices.size(); m++)
    {
        f << std::format("usemtl mat_{}\n", m);
        for (uint32_t i = 0; i < indexCounts.at(m) / 3; i++)
        {
            const uint32_t i0 = indices.at(m).at(i * 3 + 0) + 1;
            const uint32_t i1 = indices.at(m).at(i * 3 + 1) + 1;
            const uint32_t i2 = indices.at(m).at(i * 3 + 2) + 1;
            f << std::format("f {}/{}/{} {}/{}/{} {}/{}/{}\n", i0, i0, i0, i1, i1, i1, i2, i2, i2);
        }
        f << "\n";
    }

    f.close();
}

void ModelLod::Write(DataWriter &writer) const
{
    writer.Write<float>(distance);
    writer.Write<size_t>(vertices.size());
    for (const ModelVertex &vertex: vertices)
    {
        writer.WriteBuffer<float, 3>(vertex.position);
        writer.WriteBuffer<float, 2>(vertex.uv);
        vertex.color.WriteFloats(writer);
        writer.WriteBuffer<float, 3>(vertex.normal);
    }
    const uint32_t totalIndexCount = std::accumulate(indexCounts.begin(), indexCounts.end(), 0ul);
    writer.Write<uint32_t>(totalIndexCount);
    writer.WriteBuffer<uint32_t>(indexCounts);
    for (const std::vector<uint32_t> &lodIndices: indices)
    {
        writer.WriteBuffer<uint32_t>(lodIndices);
    }
}

